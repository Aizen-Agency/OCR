services:
  redis:
    image: redis:7-alpine
    # SECURITY: Redis port is NOT exposed to host - only accessible within Docker network
    # ports:
    #   - "6379:6379"  # REMOVED - prevents external access
    volumes:
      - redis_data:/data
      - ./redis.conf:/usr/local/etc/redis/redis.conf:ro
    networks:
      - ocr_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
    # SECURITY: Require password authentication and use secure config
    command: >
      redis-server /usr/local/etc/redis/redis.conf
      --requirepass ${REDIS_PASSWORD}
      --bind 0.0.0.0
      --protected-mode yes
      --appendonly yes
      --maxmemory 2gb
      --maxmemory-policy allkeys-lru
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD:-change-this-redis-password-in-production}
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 512M
          cpus: '0.5'

  ocr-microservice:
    build:
      context: .
      dockerfile: Dockerfile
    # SECURITY: Port 5000 should NOT be exposed when using nginx (production profile)
    # IMPORTANT: When using --profile production, nginx handles external access
    # If running WITHOUT nginx profile, uncomment the port mapping below:
    # ports:
    #   - "5000:5000"  # Only uncomment if NOT using nginx (development mode)
    environment:
      - FLASK_ENV=production
      - PORT=5000
      - HOST=0.0.0.0
      - DEBUG=false
      - OCR_LANG=en
      - USE_GPU=false
      - USE_PP_OCR_V5_SERVER=true
      - USE_ANGLE_CLS=true
      - DET_LIMIT_SIDE_LEN=1280
      - REC_BATCH_NUM=8
      - MAX_CONTENT_LENGTH=52428800
      - SECRET_KEY=${SECRET_KEY:-change-this-in-production}
      - LOG_LEVEL=DEBUG
      # REDIS_URL will be constructed in Python with proper URL encoding for special characters
      # Do NOT set REDIS_URL here - let config.py handle URL encoding of password
      - REDIS_PASSWORD=${REDIS_PASSWORD:-change-this-redis-password-in-production}
      # CELERY_BROKER_URL and CELERY_RESULT_BACKEND will automatically use REDIS_URL from config.py
      - RATE_LIMIT_PER_MINUTE=10
      # SECURITY: API key authentication - required for /ocr/* endpoints
      - AUTH_TOKEN=${AUTH_TOKEN:-1QHRD48KoetalQhxg14KwMe1MKjRw7Mbj9BwlBUm74M=}
      # Configure PaddlePaddle cache directories explicitly
      - XDG_CACHE_HOME=/tmp/.cache
      - TMPDIR=/tmp
      - PADDLEPADDLE_CACHE_DIR=/tmp/.paddlex
    volumes:
      - ocr_uploads:/tmp/ocr_uploads
      - logs_data:/app/logs  # Use named volume instead of bind mount for read-only compatibility
      - paddlex_models:/tmp/.paddlex  # Mount volume at /tmp/.paddlex since HOME=/tmp
    restart: unless-stopped
    depends_on:
      - redis
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health/ready"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - ocr_network
    deploy:
      resources:
        limits:
          memory: 8G  # Increased for 24GB VPS - handles multiple concurrent API requests
          cpus: '4.0'  # More CPU for faster OCR processing
        reservations:
          memory: 2G
          cpus: '2.0'
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp

  celery-worker:
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      - FLASK_ENV=production
      - OCR_LANG=en
      - USE_GPU=false
      - USE_PP_OCR_V5_SERVER=true
      - USE_ANGLE_CLS=true
      - DET_LIMIT_SIDE_LEN=1280
      - REC_BATCH_NUM=8
      # REDIS_URL will be constructed in Python with proper URL encoding for special characters
      # Do NOT set REDIS_URL here - let config.py handle URL encoding of password
      - REDIS_PASSWORD=${REDIS_PASSWORD:-change-this-redis-password-in-production}
      # CELERY_BROKER_URL and CELERY_RESULT_BACKEND will automatically use REDIS_URL from config.py
      - LOG_LEVEL=DEBUG
      # SECURITY: API key authentication - required for /ocr/* endpoints
      - AUTH_TOKEN=${AUTH_TOKEN:-1QHRD48KoetalQhxg14KwMe1MKjRw7Mbj9BwlBUm74M=}
      # Configure PaddlePaddle cache directories explicitly
      - XDG_CACHE_HOME=/tmp/.cache
      - TMPDIR=/tmp
      - PADDLEPADDLE_CACHE_DIR=/tmp/.paddlex
    command: celery -A celery_app worker --loglevel=info --concurrency=4
    volumes:
      - ocr_uploads:/tmp/ocr_uploads
      - logs_data:/app/logs  # Use named volume for consistency
      - paddlex_models:/tmp/.paddlex  # Mount volume at /tmp/.paddlex since HOME=/tmp
    restart: unless-stopped
    depends_on:
      - redis
      - ocr-microservice
    healthcheck:
      test: ["CMD", "true"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 120s
    networks:
      - ocr_network
    deploy:
      resources:
        limits:
          memory: 10G  # Increased for 24GB VPS - handles async batch processing
          cpus: '4.0'  # More CPU for parallel processing
        reservations:
          memory: 3G
          cpus: '2.0'
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp

  # Optional: Add nginx reverse proxy for production
  # To start nginx, use: docker compose --profile production up
  # Or remove the 'profiles' section below to always start nginx
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      # SECURITY: Add HTTPS port when SSL certificates are configured
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      # SECURITY: Add SSL certificates when available
      - ./ssl:/etc/nginx/ssl:ro
      - logs_data:/var/log/nginx  # Mount logs volume for fail2ban access (nginx writes logs here)
    depends_on:
      - ocr-microservice
    networks:
      - ocr_network
    restart: unless-stopped
    # SECURITY: Apply security options to nginx container
    security_opt:
      - no-new-privileges:true
    # SECURITY: Read-only root filesystem (nginx needs /var/cache and /var/run writable)
    read_only: true
    tmpfs:
      - /var/cache/nginx
      - /var/run
      - /tmp
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 128M
          cpus: '0.25'
    profiles:
      - production

  fail2ban:
    image: crazymax/fail2ban:latest
    container_name: ocr-fail2ban-1
    network_mode: "host"  # Required for iptables to work properly
    cap_add:
      - NET_ADMIN
      - NET_RAW
    volumes:
      - ./fail2ban/jail.local:/etc/fail2ban/jail.d/jail.local:ro
      - ./fail2ban/nginx-auth.conf:/etc/fail2ban/filter.d/nginx-auth.conf:ro
      - ./fail2ban/nginx-limit-req.conf:/etc/fail2ban/filter.d/nginx-limit-req.conf:ro
      - logs_data:/var/log/nginx:ro  # Mount nginx logs from logs_data volume
      - fail2ban_data:/data
    restart: unless-stopped
    depends_on:
      - nginx
    profiles:
      - production

volumes:
  ocr_uploads:
    driver: local
  redis_data:
    driver: local
  logs_data:
    driver: local
  paddlex_models:
    driver: local
  fail2ban_data:
    driver: local

networks:
  ocr_network:
    driver: bridge
